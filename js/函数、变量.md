### 变量

声明变量的方法：var、let、const

区别：

* let和const声明变量在其块级作用域中有效，var可跨块
* var声明变量存在变量提升到函数顶部，可在声明前使用值为undefined
* let和const会产生暂时性死区，只有在声明变量后才可以获取和使用
* let和const不允许重复声明
* const变量**指向的内存地址**保存的数据不得改变

### 函数

* 函数本质是一个对象，函数名是指向对象的指针
* 函数实参在内部表现为arguments类数组的形式，并且js为动态语言不会进行类型检测，所以不存在函数签名，没有重载

#### 变量函数提升

js引擎遇到var和function声明时会将它们提升到代码顶部

规则：**函数提升优于变量提升**，变量声明不能覆盖函数声明，变量赋值可以覆盖

#### 函数闭包

* 是什么：闭包是**有权访问其他函数作用域的函数**
* 为什么：不使用全局变量，可以重用函数中的局部变量
* 匿名函数的执行环境是全局性的，所以**匿名函数中this指向全局变量**
* 产生原理：与作用域链相关，函数在调用时会创建函数执行上下文，并将函数作用域链（在函数声明时就初始化为外部作用域链）添加到内部属性[[scope]]上，然后将this、arguments、内部定义变量初始化为活动变量添加到作用域链前端。访问变量时会沿着作用域链查找，而**作用域链的本质是一个指向变量对象的指针列表**。
* 弊端：**造成内存泄漏**，一般情况下，当函数执行完毕后，局部活动变量将被销毁，但是由于其内部函数的作用域链上仍然引用了该局部活动变量，所以它仍需保存在内存中，直到该闭包销毁。
* 应用：
  * 立即执行函数：使用全局变量容易造成内存泄漏、命名冲突等问题
  * 函数结果缓存：当一个复杂的函数时，每次调用都需很长时间，想要将结果缓存，否则调用完之后局部变量销毁。使用闭包不会释放外部变量对象，可以得到缓存的效果。

#### 函数柯里化

柯里化是指将接收多个参数的函数变换成接收一个单一参数的函数，并返回接收余下参数且返回结果的新函数。

主要作用及特点：**参数复用、提前返回、延迟执行**

**其实现方式：需要依赖参数以及递归，通过拆分参数的方式，来调用一个多参数的函数方法，以达到减少代码冗余，增加可读性的目的。**

```js
function curry(fn, args) {
    var length = fn.length;
    var args = args || [];
    return function(){
        newArgs = args.concat(Array.prototype.slice.call(arguments));
        if(newArgs.length < length){
            console.log(newArgs)
            return curry.call(this,fn,newArgs);
        }else{
            return fn.apply(this,newArgs);
        }
    }
}
```

