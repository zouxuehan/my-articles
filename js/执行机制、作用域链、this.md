#### 执行机制

因为js是单线程脚本语言，处理任务是一件一件进行，如果有一个任务处理时间很长的话，后面的任务将等待造成阻塞。

所以js通过eventLoop事件循环机制解决这个问题：

1. 当js引擎开始执行js脚本，创建全局执行上下文推入执行栈中
2. 任务调用时创建函数执行上下文推入执行栈
   * 如果是同步任务，立即执行后出栈
   * 如果是异步任务，则将其交给浏览器其他线程处理（如setTimeout由定时触发器线程处理、事件由事件触发线程处理、ajax请求由异步http请求线程处理）
   * 处理完成的回调函数进入任务队列中，分为宏任务和微任务

3. 当执行栈任务执行完毕为空，去任务队列中读取对应回调，先执行微任务队列中回调，再执行宏任务中回调
4. 不断重复上述过程

![img](https://user-gold-cdn.xitu.io/2018/1/20/16112dee30db2997?imageslim)

宏任务：http请求、setTimeout、setInterval、事件

微任务：promise、process.nextTick、MutationObserver

#### 作用域

全局作用域：变量对象为全局变量

函数作用域：变量对象为arguments+函数定义变量

块级作用域：es5中没有块级作用域，代码块中var定义的变量实际包含在外部作用域中

```js
function a(){
     for(var i=0;i<10;i++){
         setTimeout(function(){
             console.log(i)
         },500)
     }
}
a() // 10,10,10...
// js没有块级作用域，所以打印的i都指向的是a函数作用域中的i
```

* 函数闭包模仿块级作用域

  ```js
  function a(){
      for(var i=0;i<10;i++){
          (function(j){
              setTimeout(function(){
                  console.log(j)
              },500)
          })(i)
      }
  }
  ```

  es6中let和const定义变量

> 当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。因此，在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量， 或抵达最外层的作用域（也就是全局作用域）为止。

#### 作用域链

在js高程中提到：

1. 当调用函数时，会创建该函数的执行上下文及相应的作用域链，并将作用域链赋值给内部属性[[scope]]（**函数创建时就初始化作用域链为外部函数的作用域链**）
2. 使用this、arguments和函数定义参数初始化函数的活动对象
3. 将活动对象推到执行上下文作用域链的前端

所以**作用域链的本质其实是一个指向变量对象的指针列表**

![Image](C:\Users\ADMINI~1\AppData\Local\Temp\Image.png)

#### this

* 当函数调用时，会进行this绑定，this总是指向最后调用它的对象
* 匿名函数中的this始终指向全局对象
* 箭头函数中的this始终指向函数定义时所在的对象，因为箭头函数没有this绑定这一步，所以必须通过作用域链查找this
* 改变this指向的方法有call、apply、bind
  * call和apply都传入指定this的对象，区别：call直接传多个参数，apply传数组
  * bind创建一个新的函数，不立即执行