### OSI七层模型

* 应用层：文件传输，HTTP、FTP

* 表示层：数据格式化、代码格式、数据加密

* 会话层：建立、解除会话

* 传输层：提供端对端接口，TCP、UDP

* 网络层：为数据包选择路由，IP

  **IP协议的作用：把各种数据包传送给对方，为确保传送正确，必须带IP地址和MAC地址**

* 数据链路层：传输有地址的帧

* 物理层：二进制数据形式在物理媒体上传输

### TCP协议三次握手四次挥手

tcp协议位于传输层，提供可靠的字节流服务，保证数据精确无误的传送到目的地。

* **三次握手建立连接**：

  1. 客户端发送SYN包给服务器，进入SYN-SENT状态，等待服务器确认
  2. 服务器接收到SYN包，确认后，发送SYN+ACK包，进入SYN-RCVD状态
  3. 客户端收到SYN+ACK包后，再次发送ACK确认包，发送完毕后，都进入已连接状态

  ![img](https://img-blog.csdn.net/20180717202520531?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTUwMzE2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

* **四次挥手断开连接**

  1. 客户端发送连接释放包FIN=1，并停止发送数据
  2. 服务器接收到后，发送ACK确认包，此时客户端向服务器方向释放，处于半关闭状态，即客户端不向服务器发送数据，但是需要接收服务器发送的数据
  3. 服务器最后数据发送完毕后，向客户端发送连接释放报文FIN=1，ACK=1
  4. 客户端收到后发送ACK确认包，但需要经过最长报文段寿命时间才关闭

  ![img](https://img-blog.csdn.net/20180717204202563?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTUwMzE2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

* 为什么要三次挥手而不是两次

  如果改成两次挥手，服务器发送确认报文后，就认为客户端接收到而发送数据，但是此时若客户端并没有接收到该确认报文，将认为连接并未建立，忽略发送数据，形成死锁

* 为什么连接是三次，挥手是四次

  服务器接收到SYN连接请求报文后，可以同时发送SYN+ACK报文，但是关闭连接时，接收到FIN报文后，可能不会立即关闭连接，只能先发送确认报文，等服务器所有数据发送完后才能发送FIN报文。

### DNS

DNS协议提供通过域名查找IP地址，或逆向查找的服务

### HTTP协议

#### 报文

* 请求报文：由请求方法、请求URI、协议版本、可选请求首部、内容实体组成
* 响应报文：协议版本、状态码、解释、响应首部、主体

#### 方法

* GET：从指定资源
* POST：传输实体主体
* HEAD：类似get，但只获得报文首部
* OPTIONS：查询针对指定资源支持的方法

#### 状态码

**2XX：请求正常处理**

* 200：请求成功
* 204：无内容；服务器处理请求成功，但是响应报文无实体主体
* 206：部分内容；客户端进行范围请求，服务器返回指定范围实体

**3XX：重定向，浏览器需要执行某些特殊处理**

* 301：永久重定向，请求资源被重新分配URI，之后所有请求都定位到新URI（**使用域名跳转**）
* 302：临时重定向，只有本次使用新URI（**临时跳转，未登录用户重定向到登录页面**）
* 303：查看其他地址，与302类似，应采用GET方法
* 304：无变化，客户端发送附带条件的GET请求，资源不符合条件时，不返回实体内容。

**4XX：客户端错误**

* 400：客户端请求语法错误，服务器无法理解
* 401：请求需要通过HTTP认证
* 403：请求被服务器拒绝
* 404：服务器无法找到请求资源

**5XX：服务器错误**

* 500：服务器执行请求时错误
* 502 ：  作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应
* 503：服务器超负载或正系统维护
* 504：充当网关、代理的服务器未及时从远端服务器获取

#### 代理、网关

代理扮演“**中间人**”角色，接收客户端发送的请求，并将其转发给源服务器

**为什么使用代理？**可利用缓存技术减少网络带宽的流量。代理转发响应时，缓存代理会预先将资源缓存保存到代理服务器上，再次请求相同资源，就不需要从源服务器获取，而是直接将缓存资源作为响应。

网关**将HTTP请求转换为其他协议**通信，可加密，能提高通信安全性。

#### 缓存

缓存：代理服务器或客户端本地磁盘内保存资源副本。利用缓存可减少对源服务器的访问，节约通信流量和时间。

![image-20210301101703480](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210301101703480.png)

|          | 获取资源形式 | 状态码              | 发送请求到服务器                 |
| -------- | ------------ | ------------------- | -------------------------------- |
| 强缓存   | 从本地缓存取 | 200（from cache）   | 否，直接从缓存取                 |
| 协商缓存 | 从代理缓存取 | 304（not modified） | 是，通过服务器来告知缓存是否可用 |

**强缓存头部字段**

* expires：GMT格式时间字符串，表示缓存失效时间
* cache-control：

协商缓存头部字段：

* if-none-match/etag：
* if-modified-since/last-modified:

![img](https://images2015.cnblogs.com/blog/408483/201605/408483-20160525182943272-204994049.png)

#### HEAD头部字段

通用首部：

* **cache-control**：控制缓存行为
  * no-cache：缓存向源服务器进行过期确认处理
  * no-store：不能缓存
  * max-age：缓存有效时间
* **conection**：
  * 控制不再转发的首部字段
  * 管理持久连接，HTTP/1.1默认为持久连接keep-alive
* **data**：报文创建时间
* via：通过的代理

请求首部：

* **accept**：可接收的响应内容类型
* authorization：认证信息
* host：主机名+端口号
* **if-match**：附带条件，判断为真才会执行请求（只有if-match和etag匹配）
* **if-none-match**：
* **if-modified-since**：指定日期之后资源更新（last-modified），

响应首部：

* **etag**：资源以字符串形式做唯一标识
* server：服务器上http服务器应用程序信息
* vary：对缓存进行控制，源服务器会向代理服务器传达关于本地缓存使用方法的命令。

实体首部：

* expires：资源失效日期
* last-modified：最后修改时间

#### cookie

http是无状态协议，它不对之前发生过的请求和响应状态进行管理。

cookie根据服务器发送的响应报文中的set-cookie，通知客户端保存cookie，下次发送请求时，会自动在请求中加入cookie值发送。

**构成**

* **name/value**：名/值，都经过URL编码
* **Expires/Max-Age**：cookie过期时间，可以通过**设置Expires为过去时间清除cookie**
* **Domain/path**：cookie可送达的主机名/路径，默认为当前页面主机名，**不可跨域设置**
* **secure**：只能通过被https协议加密过的请求发送给服务器
* **HTTPOnly**：不可通过js获取，设置后可**防御XSS攻击**
* **SameSite**：可设置为Strict、Lax、None，跨站请求时不会被发送，**可阻止CSRF攻击**

### https

为什么？**http缺点**：

* 使用明文通信，内容可能被窃听
* 不验证通信方身份，可能遭遇伪装
* 无法证明报文完整性，可能遭篡改

https：与SSL组合使用的http，用SSL建立安全通信线路后，进行http通信。

**https=http+加密+认证+完整性保护**

**工作原理**：

* 客户端发送https请求，要求服务器建立SSL安全连接
* 服务器接收后，将网站证书传输给客户端
* 客户端和服务器协商SSL安全加密等级
* 双方协商一致后建立会话密钥，通过网站公钥加密会话密钥传送给网站
* 服务器通过私钥解密会话密钥
* 服务器通过会话密钥加密与客户端之间的通信

**https缺点**：

* 加密通信消耗更多CPU及内存资源
* 建立SSL安全连接耗时更长
* SSL证书开销

### webSocket

是通过长时连接实现与服务器全双工、双向通信、不受同源策略影响。

http协议的一个response只对应一个request，且是被动的，不能主动发起。

基于两个首部属性：

* upgrade：websocket
* connection：upgrade

### http2

**http1.1相对优化**：

* 持久连接，**一个TCP可以传输多个HTTP请求**，只要没有断开连接指令则一直保持
* 每个**域名最多同时维护6个TCP连接**
* 使用CDN实现域名分片机制

**http1.1问题**：

* 开启多条TCP连接，会竞争固定带宽
* 队头阻塞，在一个管道中同一时刻只能处理一个请求，顺序处理，其他请求处于阻塞

**http2优化**：

一个域名只使用一个TCP长连接，并使用**多路复用机制**消除队头阻塞问题

* **多路复用机制**：引入二进制分帧层，将所有的传输信息处理成带id编号的更小帧，接收到之后再合并处理
* **头部压缩**
* **服务器端推送**：将数据提前推送给客户端



### 安全

#### **XSS(跨站脚本攻击)**：往html文件或DOM中注入恶意脚本

* **存储型XSS**：通过表单提交将js恶意脚本提交到服务器，之后再向服务器请求时将执行该恶意脚本，通常该脚本可以获取到用户的cookie信息
* **反射型XSS**：通过url将含恶意代码的请求提交给服务器，又将恶意代码反射回客户端，执行恶意代码

防御：

1. 对输入脚本进行**转义**
2. cookie设置**httpOnly**标记，不能从js获取
3. 使用**CSP策略**

#### CSRF(跨站请求伪造)：利用用户的登录状态，通过第三方站点攻击

防御：

1. **cookie设置samesite**，跨站请求不发送cookie
2. 服务端**设置tooken**，客户端进行存储，**CSRF不能从页面获取信息**

#### SQL注入：

当需要对数据库表内的数据进行 检索或添加、删除等操作时，会使用 SQL语句连接数据库进行 特定的操作。如果在调用 SQL语句的方式上存在疏漏，就有可能执行被恶意注入（Injection）非法 SQL语句